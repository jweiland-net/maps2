{"version":3,"sources":["GoogleMaps2.js"],"names":["GoogleMaps2","allMarkers","categorizedMarkers","pointMarkers","bounds","infoWindow","poiCollections","editable","map","constructor","element","environment","lat","lng","this","google","maps","LatLngBounds","InfoWindow","JSON","parse","dataset","pois","classList","contains","setMapDimensions","settings","createMap","Number","latitude","longitude","createMarkerByLatLng","setCenter","LatLng","extConf","defaultLatitude","defaultLongitude","createPointByCollectionType","markerClusterer","enable","MarkerClusterer","imagePath","countObjectProperties","showSwitchableCategories","forceZoom","length","collectionType","fitBounds","getMapOptions","let","mapOptions","mapTypeId","zoom","parseInt","zoomControl","mapTypeControl","scaleControl","streetViewControl","fullscreenControl","fullScreenControl","scrollwheel","activateScrollWheel","styles","eval","MapTypeId","HYBRID","ROADMAP","SATELLITE","TERRAIN","getCircleOptions","centerPosition","poiCollection","center","radius","strokeColor","strokeOpacity","strokeWeight","fillColor","fillOpacity","getPolygonOptions","paths","getPolylineOptions","path","Map","canBeInterpretedAsNumber","value","isNaN","normalizeDimension","dimension","normalizedDimension","String","style","height","mapHeight","width","mapWidth","groupCategories","categoryUid","groupedCategories","x","y","categories","uid","inList","hasOwnProperty","getCategoriesOfCheckboxesWithStatus","form","isChecked","querySelectorAll","forEach","checkbox","push","getMarkersToChangeVisibilityFor","markers","marker","allCategoriesOfMarker","categoriesOfCheckboxesWithStatus","i","markerCategoryHasCheckboxWithStatus","j","k","document","createElement","span","add","setAttribute","contentRecord","innerText","title","append","getCheckbox","cloneNode","querySelector","after","addEventListener","event","target","checked","setVisible","category","input","label","divCheckbox","divFormGroup","obj","count","key","createMarker","createArea","createRoute","createRadius","c","relatedCategories","icon","Marker","position","setDraggable","markerIcon","url","scaledSize","Size","markerIconWidth","markerIconHeight","anchor","Point","markerIconAnchorPosX","markerIconAnchorPosY","setIcon","extend","addEditListeners","addInfoWindow","latLng","mapPosition","area","Polygon","setMap","route","Polyline","circle","Circle","union","getBounds","addListener","fetch","ajaxUrl","method","headers","Content-Type","body","stringify","then","response","json","data","close","setContent","content","setPosition","open","catch","error","console","list","item","search","mapContainer","getPosition","toFixed","prevAll","val","maps2GoogleMaps","initMap","override","address","places","Autocomplete","fields","keyCode"],"mappings":"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","file":"GoogleMaps2.min.js","sourcesContent":["class GoogleMaps2 {\n  allMarkers = [];\n  categorizedMarkers = {};\n  pointMarkers = [];\n  bounds = {};\n  infoWindow = {};\n  poiCollections = {};\n  editable = {};\n  map = {};\n\n  /**\n   * @param {HTMLElement} element\n   * @param {Environment} environment\n   * @constructor\n   */\n  constructor (element, environment) {\n    this.allMarkers = [];\n    this.categorizedMarkers = {};\n    this.pointMarkers = [];\n    this.bounds = new google.maps.LatLngBounds();\n    this.infoWindow = new google.maps.InfoWindow();\n    this.poiCollections = JSON.parse(element.dataset.pois);\n    this.editable = element.classList.contains('editMarker');\n\n    this.setMapDimensions(element, environment.settings);\n\n    this.createMap(element, environment);\n\n    if (typeof this.poiCollections === 'undefined') {\n      // Plugin: CityMap\n      let lat = Number(element.dataset.latitude);\n      let lng = Number(element.dataset.longitude);\n      if (lat && lng) {\n        this.createMarkerByLatLng(lat, lng);\n        this.map.setCenter(new google.maps.LatLng(lat, lng));\n      } else {\n        // Fallback\n        this.map.setCenter(new google.maps.LatLng(environment.extConf.defaultLatitude, environment.extConf.defaultLongitude));\n      }\n    } else {\n      // normal case\n      this.createPointByCollectionType(element, environment);\n      if (\n        typeof environment.settings.markerClusterer !== 'undefined'\n        && environment.settings.markerClusterer.enable === 1\n      ) {\n        new MarkerClusterer(\n          this.map,\n          this.pointMarkers,\n          { imagePath: environment.settings.markerClusterer.imagePath }\n        );\n      }\n      if (this.countObjectProperties(this.categorizedMarkers) > 1) {\n        this.showSwitchableCategories(element, environment);\n      }\n      if (\n        environment.settings.forceZoom === false\n        && (\n          this.poiCollections.length > 1\n          || (\n            this.poiCollections.length === 1\n            && (\n              this.poiCollections[0].collectionType === 'Area'\n              || this.poiCollections[0].collectionType === 'Route'\n            )\n          )\n        )\n      ) {\n        this.map.fitBounds(this.bounds);\n      } else {\n        this.map.setCenter(new google.maps.LatLng(this.poiCollections[0].latitude, this.poiCollections[0].longitude));\n      }\n    }\n  }\n\n  /**\n   * Return a MapOptions object which can be assigned to the Map object of Google\n   *\n   * @param {Settings} settings\n   * @return {object}\n   */\n  getMapOptions = settings => {\n    let mapOptions = {\n      mapTypeId: '',\n      zoom: parseInt(settings.zoom),\n      zoomControl: (parseInt(settings.zoomControl) !== 0),\n      mapTypeControl: (parseInt(settings.mapTypeControl) !== 0),\n      scaleControl: (parseInt(settings.scaleControl) !== 0),\n      streetViewControl: (parseInt(settings.streetViewControl) !== 0),\n      fullscreenControl: (parseInt(settings.fullScreenControl) !== 0),\n      scrollwheel: settings.activateScrollWheel,\n      styles: ''\n    };\n\n    if (settings.styles) {\n      mapOptions.styles = eval(settings.styles);\n    }\n\n    switch (settings.mapTypeId) {\n      case 'google.maps.MapTypeId.HYBRID':\n      case 'hybrid':\n        mapOptions.mapTypeId = google.maps.MapTypeId.HYBRID;\n        break;\n      case 'google.maps.MapTypeId.ROADMAP':\n      case 'roadmap':\n        mapOptions.mapTypeId = google.maps.MapTypeId.ROADMAP;\n        break;\n      case 'google.maps.MapTypeId.SATELLITE':\n      case 'satellite':\n        mapOptions.mapTypeId = google.maps.MapTypeId.SATELLITE;\n        break;\n      case 'google.maps.MapTypeId.TERRAIN':\n      case 'terrain':\n        mapOptions.mapTypeId = google.maps.MapTypeId.TERRAIN;\n        break;\n    }\n\n    return mapOptions;\n  }\n\n  /**\n   * Returns CircleOptions which can be assigned to the Circle object of Google\n   *\n   * @param {L.Map} map\n   * @param {object} centerPosition\n   * @param {PoiCollection} poiCollection\n   * @return {object}\n   */\n  getCircleOptions (map, centerPosition, poiCollection) {\n    return {\n      map: map,\n      center: centerPosition,\n      radius: poiCollection.radius,\n      strokeColor: poiCollection.strokeColor,\n      strokeOpacity: poiCollection.strokeOpacity,\n      strokeWeight: poiCollection.strokeWeight,\n      fillColor: poiCollection.fillColor,\n      fillOpacity: poiCollection.fillOpacity\n    };\n  }\n\n  /**\n   * Returns PolygonOptions which can be assigned to the Polygon object of Google\n   *\n   * @param {object} paths\n   * @param {PoiCollection} poiCollection\n   * @return {object}\n   */\n  getPolygonOptions (paths, poiCollection) {\n    return {\n      paths: paths,\n      strokeColor: poiCollection.strokeColor,\n      strokeOpacity: poiCollection.strokeOpacity,\n      strokeWeight: poiCollection.strokeWeight,\n      fillColor: poiCollection.fillColor,\n      fillOpacity: poiCollection.fillOpacity\n    };\n  }\n\n  /**\n   * Return PolylineOptions which can be assigned to the Polyline object of Google\n   *\n   * @param {object} paths\n   * @param {PoiCollection} poiCollection\n   * @return {object}\n   */\n  getPolylineOptions (paths, poiCollection) {\n    return {\n      path: paths,\n      strokeColor: poiCollection.strokeColor,\n      strokeOpacity: poiCollection.strokeOpacity,\n      strokeWeight: poiCollection.strokeWeight,\n    };\n  }\n\n  /**\n   * Create Map\n   *\n   * @param {HTMLElement} element\n   * @param {Environment} environment\n   */\n  createMap (element, environment) {\n    this.map = new google.maps.Map(\n      element,\n      this.getMapOptions(environment.settings)\n    );\n  }\n\n  /**\n   * @param {string | number} value\n   * @return {boolean}\n   */\n  canBeInterpretedAsNumber(value) {\n    return typeof value === 'number' || !isNaN(Number(value));\n  }\n\n  /**\n   * @param {string | number} dimension\n   * @returns {string}\n   */\n  normalizeDimension(dimension) {\n    let normalizedDimension = String(dimension);\n\n    if (this.canBeInterpretedAsNumber(normalizedDimension)) {\n      normalizedDimension += 'px';\n    }\n\n    return normalizedDimension;\n  }\n\n  /**\n   * @param {HTMLElement} element\n   * @param {Settings} settings\n   */\n  setMapDimensions(element, settings) {\n    element.style.height = this.normalizeDimension(settings.mapHeight);\n    element.style.width = this.normalizeDimension(settings.mapWidth);\n  }\n\n  /**\n   * Group Categories\n   *\n   * @param {Environment} environment\n   */\n  groupCategories = environment => {\n    let groupedCategories = {};\n    let categoryUid = \"0\";\n    for (let x = 0; x < this.poiCollections.length; x++) {\n      for (let y = 0; y < this.poiCollections[x].categories.length; y++) {\n        categoryUid = String(this.poiCollections[x].categories[y].uid);\n        if (this.inList(environment.settings.categories, categoryUid) > -1 && !groupedCategories.hasOwnProperty(categoryUid)) {\n          groupedCategories[categoryUid] = this.poiCollections[x].categories[y];\n        }\n      }\n    }\n\n    return groupedCategories;\n  };\n\n  /**\n   * Get categories of all checkboxes with a given status\n   *\n   * @param {HTMLElement} form The HTML form element containing the checkboxes\n   * @param {boolean} isChecked Get checkboxes of this status only\n   */\n  getCategoriesOfCheckboxesWithStatus = (form, isChecked) => {\n    let categories = [];\n    let checkboxes = isChecked ? form.querySelectorAll(\"input:checked\") : form.querySelectorAll(\"input:not(input:checked)\");\n\n    checkboxes.forEach(checkbox => {\n      categories.push(parseInt(checkbox.value));\n    });\n\n    return categories;\n  }\n\n  getMarkersToChangeVisibilityFor = (categoryUid, form, isChecked) => {\n    let markers = [];\n    if (this.allMarkers.length === 0) {\n      return markers;\n    }\n\n    let marker = null;\n    let allCategoriesOfMarker = null;\n    let categoriesOfCheckboxesWithStatus = this.getCategoriesOfCheckboxesWithStatus(form, isChecked);\n    for (let i = 0; i < this.allMarkers.length; i++) {\n      marker = this.allMarkers[i];\n      allCategoriesOfMarker = marker.poiCollection.categories;\n      if (allCategoriesOfMarker.length === 0) {\n        continue;\n      }\n\n      let markerCategoryHasCheckboxWithStatus;\n      for (let j = 0; j < allCategoriesOfMarker.length; j++) {\n        markerCategoryHasCheckboxWithStatus = false;\n        for (let k = 0; k < categoriesOfCheckboxesWithStatus.length; k++) {\n          if (allCategoriesOfMarker[j].uid === categoriesOfCheckboxesWithStatus[k]) {\n            markerCategoryHasCheckboxWithStatus = true;\n          }\n        }\n        if (markerCategoryHasCheckboxWithStatus === isChecked) {\n          break;\n        }\n      }\n\n      if (markerCategoryHasCheckboxWithStatus) {\n        markers.push(marker.marker);\n      }\n    }\n\n    return markers;\n  }\n\n  /**\n   * Show switchable categories\n   *\n   * @param {HTMLElement} element\n   * @param {Environment} environment\n   */\n  showSwitchableCategories = (element, environment) => {\n    let categories = this.groupCategories(environment);\n    let form = document.createElement(\"form\");\n    let span = {};\n\n    form.classList.add(\"txMaps2Form\");\n    form.setAttribute(\"id\", \"txMaps2Form-\" + environment.contentRecord.uid);\n\n    // Add checkbox for category\n    for (let categoryUid in categories) {\n      if (categories.hasOwnProperty(categoryUid)) {\n        span = document.createElement(\"span\");\n        span.classList.add(\"map-category\");\n        span.innerText = categories[categoryUid].title;\n\n        form.append(this.getCheckbox(categories[categoryUid]).cloneNode(true));\n        form.querySelector(\"#checkCategory_\" + categoryUid).after(span.cloneNode(true));\n      }\n    }\n\n    // Add listener for checkboxes\n    form.querySelectorAll(\"input\").forEach(checkbox => {\n      checkbox.addEventListener(\"click\", event => {\n        let isChecked = event.target.checked;\n        let categoryUid = event.target.value;\n        let markers = this.getMarkersToChangeVisibilityFor(categoryUid, form, isChecked);\n\n        for (let i = 0; i < markers.length; i++) {\n          markers[i].setVisible(isChecked);\n        }\n      });\n    });\n\n    element.after(form.cloneNode(true));\n  }\n\n  /**\n   * Get Checkbox for Category\n   *\n   * @param category\n   */\n  getCheckbox = category => {\n    let input = document.createElement(\"input\");\n    let label = document.createElement(\"label\");\n    let divCheckbox = document.createElement(\"div\");\n    let divFormGroup = document.createElement(\"div\");\n\n    input.setAttribute(\"type\", \"checkbox\");\n    input.setAttribute(\"class\", \"checkCategory\");\n    input.setAttribute(\"id\", \"checkCategory_\" + category.uid);\n    input.setAttribute(\"checked\", \"checked\");\n    input.setAttribute(\"value\", category.uid);\n\n    divCheckbox.setAttribute(\"class\", \"checkbox\");\n\n    divFormGroup.setAttribute(\"class\", \"form-group\");\n\n    label.append(input.cloneNode(true));\n    divCheckbox.append(label.cloneNode(true));\n    divFormGroup.append(divCheckbox.cloneNode(true));\n\n    return divFormGroup;\n  }\n\n  /**\n   * Count Object properties\n   *\n   * @param obj\n   */\n  countObjectProperties = obj => {\n    let count = 0;\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /**\n   * Create Point by CollectionType\n   *\n   * @param {HTMLElement} element\n   * @param {Environment} environment\n   */\n  createPointByCollectionType = (element, environment) => {\n    let marker;\n    let categoryUid = 0;\n\n    this.poiCollections.forEach(poiCollection => {\n      if (poiCollection.strokeColor === \"\") {\n        poiCollection.strokeColor = environment.extConf.strokeColor;\n      }\n      if (poiCollection.strokeOpacity === \"\") {\n        poiCollection.strokeOpacity = environment.extConf.strokeOpacity;\n      }\n      if (poiCollection.strokeWeight === \"\") {\n        poiCollection.strokeWeight = environment.extConf.strokeWeight;\n      }\n      if (poiCollection.fillColor === \"\") {\n        poiCollection.fillColor = environment.extConf.fillColor;\n      }\n      if (poiCollection.fillOpacity === \"\") {\n        poiCollection.fillOpacity = environment.extConf.fillOpacity;\n      }\n\n      marker = null;\n      switch (poiCollection.collectionType) {\n        case \"Point\":\n          marker = this.createMarker(poiCollection, element, environment);\n          break;\n        case \"Area\":\n          marker = this.createArea(poiCollection, environment);\n          break;\n        case \"Route\":\n          marker = this.createRoute(poiCollection, environment);\n          break;\n        case \"Radius\":\n          marker = this.createRadius(poiCollection, environment);\n          break;\n      }\n\n      if (marker !== null) {\n        this.allMarkers.push({\n          marker: marker,\n          poiCollection: poiCollection\n        });\n\n        categoryUid = 0;\n        for (let c = 0; c < poiCollection.categories.length; c++) {\n          categoryUid = poiCollection.categories[c].uid;\n          if (!this.categorizedMarkers.hasOwnProperty(categoryUid)) {\n            this.categorizedMarkers[categoryUid] = [];\n          }\n          this.categorizedMarkers[categoryUid].push({\n            marker: marker,\n            relatedCategories: poiCollection.categories\n          });\n        }\n      }\n    });\n  }\n\n  /**\n   * Create Marker with InfoWindow\n   *\n   * @param {PoiCollection} poiCollection\n   * @param {HTMLElement} element\n   * @param {Environment} environment\n   */\n  createMarker = (poiCollection, element, environment) => {\n    let categoryUid = \"0\";\n    let marker = new google.maps.Marker({\n      position: new google.maps.LatLng(poiCollection.latitude, poiCollection.longitude),\n      map: this.map\n    });\n    marker.setDraggable(this.editable);\n\n    // assign first found marker icon, if available\n    if (poiCollection.hasOwnProperty(\"markerIcon\") && poiCollection.markerIcon !== \"\") {\n      let icon = {\n        url: poiCollection.markerIcon,\n        scaledSize: new google.maps.Size(poiCollection.markerIconWidth, poiCollection.markerIconHeight),\n        anchor: new google.maps.Point(poiCollection.markerIconAnchorPosX, poiCollection.markerIconAnchorPosY)\n      };\n      marker.setIcon(icon);\n    }\n\n    this.pointMarkers.push(marker);\n    this.bounds.extend(marker.position);\n\n    if (this.editable) {\n      this.addEditListeners(element, marker, poiCollection, environment);\n    } else {\n      this.addInfoWindow(marker, poiCollection, environment);\n    }\n\n    return marker;\n  }\n\n  /**\n   * Create Area\n   *\n   * @param poiCollection\n   * @param environment\n   */\n  createArea = (poiCollection, environment) => {\n    let latLng;\n    let paths = [];\n    for (let i = 0; i < poiCollection.pois.length; i++) {\n      latLng = new google.maps.LatLng(poiCollection.pois[i].latitude, poiCollection.pois[i].longitude);\n      this.bounds.extend(latLng);\n      paths.push(latLng);\n    }\n\n    if (paths.length === 0) {\n      paths.push(this.mapPosition);\n    }\n\n    let area = new google.maps.Polygon(this.getPolygonOptions(paths, poiCollection));\n    area.setMap(this.map);\n    this.addInfoWindow(area, poiCollection, environment);\n\n    return area;\n  }\n\n  /**\n   * Create Route\n   *\n   * @param poiCollection\n   * @param environment\n   */\n  createRoute = (poiCollection, environment) => {\n    let latLng;\n    let paths = [];\n    for (let i = 0; i < poiCollection.pois.length; i++) {\n      latLng = new google.maps.LatLng(poiCollection.pois[i].latitude, poiCollection.pois[i].longitude);\n      this.bounds.extend(latLng);\n      paths.push(latLng);\n    }\n\n    if (paths.length === 0) {\n      paths.push(this.mapPosition);\n    }\n\n    let route = new google.maps.Polyline(this.getPolylineOptions(paths, poiCollection));\n    route.setMap(this.map);\n    this.addInfoWindow(route, poiCollection, environment);\n\n    return route;\n  }\n\n  /**\n   * Create Radius\n   *\n   * @param poiCollection\n   * @param environment\n   */\n  createRadius = (poiCollection, environment) => {\n    let circle = new google.maps.Circle(\n      this.getCircleOptions(\n        this.map,\n        new google.maps.LatLng(poiCollection.latitude, poiCollection.longitude),\n        poiCollection\n      )\n    );\n\n    this.bounds.union(circle.getBounds());\n    this.addInfoWindow(circle, poiCollection, environment);\n\n    return circle;\n  }\n\n  /**\n   * Add Info Window to element\n   *\n   * @param element\n   * @param poiCollection\n   * @param environment\n   */\n  addInfoWindow = (element, poiCollection, environment) => {\n    // we need these both vars to be set global. So that we can access them in Listener\n    let infoWindow = this.infoWindow;\n    let map = this.map;\n    google.maps.event.addListener(element, \"click\", event => {\n      fetch(environment.ajaxUrl, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          poiCollection: poiCollection.uid\n        })\n      })\n        .then(response => response.json())\n        .then(data => {\n          infoWindow.close();\n          infoWindow.setContent(data.content);\n\n          // Do not set pointer of InfoWindow to the same pointer of the POI icon.\n          // In case of Point the pointer of InfoWindow should be at mouse position.\n          if (poiCollection.collectionType === \"Point\") {\n            infoWindow.setPosition(null);\n            infoWindow.open(map, element);\n          } else {\n            infoWindow.setPosition(new google.maps.LatLng(poiCollection.latitude, poiCollection.longitude));\n            infoWindow.open(map);\n          }\n        })\n        .catch(error => console.error('Error:', error));\n    });\n  }\n\n  /**\n   * Check for item in list\n   * Check if an item exists in a comma-separated list of items.\n   *\n   * @param list\n   * @param item\n   */\n  inList = (list, item) => {\n    let catSearch = ',' + list + ',';\n    item = ',' + item + ',';\n    return catSearch.search(item);\n  };\n\n  /**\n   * Create Marker with InfoWindow\n   *\n   * @param latitude\n   * @param longitude\n   */\n  createMarkerByLatLng = (latitude, longitude) => {\n    let marker = new google.maps.Marker({\n      position: new google.maps.LatLng(latitude, longitude),\n      map: this.map\n    });\n    this.bounds.extend(marker.position);\n  };\n\n  /**\n   * Add Edit Listeners\n   * This will only work for Markers (Point)\n   *\n   * @param mapContainer\n   * @param marker\n   * @param poiCollection\n   * @param environment\n   */\n  addEditListeners = (mapContainer, marker, poiCollection, environment) => {\n    // update fields and marker while dragging\n    google.maps.event.addListener(marker, 'dragend', () => {\n      let lat = marker.getPosition().lat().toFixed(6);\n      let lng = marker.getPosition().lng().toFixed(6);\n      mapContainer.prevAll(\"input.latitude-\" + environment.contentRecord.uid).val(lat);\n      mapContainer.prevAll(\"input.longitude-\" + environment.contentRecord.uid).val(lng);\n    });\n\n    // update fields and marker when clicking on the map\n    google.maps.event.addListener(this.map, 'click', event => {\n      marker.setPosition(event.latLng);\n      mapContainer.prevAll(\"input.latitude-\" + environment.contentRecord.uid).val(event.latLng.lat().toFixed(6));\n      mapContainer.prevAll(\"input.longitude-\" + environment.contentRecord.uid).val(event.latLng.lng().toFixed(6));\n    });\n  };\n}\n\nlet maps2GoogleMaps = [];\n\n/**\n * This function will be called by the &callback argument of the Google Maps API library\n */\nfunction initMap () {\n  document.querySelectorAll(\".maps2\").forEach(element => {\n    const environment = typeof element.dataset.environment !== 'undefined' ? element.dataset.environment : '{}';\n    const override = typeof element.dataset.override !== 'undefined' ? element.dataset.override : '{}';\n\n    maps2GoogleMaps.push(new GoogleMaps2(\n      element,\n      {...JSON.parse(environment), ...JSON.parse(override)}\n    ));\n  });\n\n  // Initialize radius search\n  let address = document.querySelector('#maps2Address');\n  let radius = document.querySelector('#maps2Radius');\n  if (address !== null && radius !== null) {\n    let autocomplete = new google.maps.places.Autocomplete(address, {\n      fields: [\n        \"place_id\"\n      ]\n    });\n\n    address.addEventListener(\"keydown\", event => {\n      if (event.keyCode === 13) return false;\n    });\n  }\n}\n"]}