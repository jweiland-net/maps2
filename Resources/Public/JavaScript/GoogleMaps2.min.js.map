{"version":3,"sources":["GoogleMaps2.js"],"names":["GoogleMaps2","allMarkers","categorizedMarkers","pointMarkers","bounds","infoWindow","poiCollections","editable","map","constructor","element","environment","lat","lng","this","google","maps","LatLngBounds","InfoWindow","JSON","parse","dataset","pois","classList","contains","setMapDimensions","settings","createMap","Number","latitude","longitude","createMarkerByLatLng","setCenter","LatLng","extConf","defaultLatitude","defaultLongitude","createPointByCollectionType","markerClusterer","enable","MarkerClusterer","imagePath","countObjectProperties","showSwitchableCategories","shouldFitBounds","fitBounds","getMapOptions","let","mapOptions","mapTypeId","zoom","parseInt","zoomControl","mapTypeControl","scaleControl","streetViewControl","fullscreenControl","fullScreenControl","scrollwheel","activateScrollWheel","styles","eval","MapTypeId","HYBRID","ROADMAP","SATELLITE","TERRAIN","getCircleOptions","centerPosition","poiCollection","center","radius","strokeColor","strokeOpacity","strokeWeight","fillColor","fillOpacity","getPolygonOptions","paths","getPolylineOptions","path","Map","canBeInterpretedAsNumber","value","isNaN","normalizeDimension","dimension","normalizedDimension","String","forceZoom","length","collectionType","style","height","mapHeight","width","mapWidth","groupCategories","categoryUid","groupedCategories","x","y","categories","uid","inList","hasOwnProperty","getCategoriesOfCheckboxesWithStatus","form","isChecked","querySelectorAll","forEach","checkbox","push","getMarkersToChangeVisibilityFor","markers","marker","allCategoriesOfMarker","categoriesOfCheckboxesWithStatus","i","markerCategoryHasCheckboxWithStatus","j","k","document","createElement","add","setAttribute","contentRecord","appendChild","getCheckbox","querySelector","insertAdjacentHTML","title","addEventListener","checked","setVisible","insertAdjacentElement","category","div","innerHTML","obj","count","key","createMarker","createArea","createRoute","createRadius","c","relatedCategories","icon","Marker","position","setDraggable","markerIcon","url","scaledSize","Size","markerIconWidth","markerIconHeight","anchor","Point","markerIconAnchorPosX","markerIconAnchorPosY","setIcon","extend","addEditListeners","addInfoWindow","latLng","mapPosition","area","Polygon","setMap","route","Polyline","circle","Circle","union","getBounds","event","addListener","fetch","ajaxUrl","method","headers","Content-Type","body","stringify","then","response","json","data","close","setContent","content","setPosition","open","catch","error","console","list","item","search","mapContainer","getPosition","toFixed","prevAll","val","maps2GoogleMaps","initMap","override","arguments","extended","deep","Object","prototype","toString","call","prop","address","places","Autocomplete","fields","keyCode"],"mappings":"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","file":"GoogleMaps2.min.js","sourcesContent":["class GoogleMaps2 {\n  allMarkers = [];\n  categorizedMarkers = {};\n  pointMarkers = [];\n  bounds = {};\n  infoWindow = {};\n  poiCollections = {};\n  editable = {};\n  map = {};\n\n  /**\n   * @param {HTMLElement} element\n   * @param {Environment} environment\n   * @constructor\n   */\n  constructor (element, environment) {\n    this.allMarkers = [];\n    this.categorizedMarkers = {};\n    this.pointMarkers = [];\n    this.bounds = new google.maps.LatLngBounds();\n    this.infoWindow = new google.maps.InfoWindow();\n    this.poiCollections = JSON.parse(element.dataset.pois || \"null\");\n    this.editable = element.classList.contains('editMarker');\n\n    this.setMapDimensions(element, environment.settings);\n\n    this.createMap(element, environment);\n\n    if (typeof this.poiCollections === 'undefined' || this.poiCollections === null) {\n      // Plugin: CityMap\n      let lat = Number(element.dataset.latitude);\n      let lng = Number(element.dataset.longitude);\n      if (lat && lng) {\n        this.createMarkerByLatLng(lat, lng);\n        this.map.setCenter(new google.maps.LatLng(lat, lng));\n      } else {\n        // Fallback\n        this.map.setCenter(new google.maps.LatLng(environment.extConf.defaultLatitude, environment.extConf.defaultLongitude));\n      }\n    } else {\n      // normal case\n      this.createPointByCollectionType(element, environment);\n      if (\n        typeof environment.settings.markerClusterer !== 'undefined'\n        && environment.settings.markerClusterer.enable === 1\n      ) {\n        new MarkerClusterer(\n          this.map,\n          this.pointMarkers,\n          { imagePath: environment.settings.markerClusterer.imagePath }\n        );\n      }\n\n      if (this.countObjectProperties(this.categorizedMarkers) > 1) {\n        this.showSwitchableCategories(element, environment);\n      }\n\n      if (this.shouldFitBounds(environment.settings)) {\n        this.map.fitBounds(this.bounds);\n      } else {\n        this.map.setCenter(new google.maps.LatLng(this.poiCollections[0].latitude, this.poiCollections[0].longitude));\n      }\n    }\n  }\n\n  /**\n   * Return a MapOptions object which can be assigned to the Map object of Google\n   *\n   * @param {Settings} settings\n   * @return {object}\n   */\n  getMapOptions = settings => {\n    let mapOptions = {\n      mapTypeId: '',\n      zoom: parseInt(settings.zoom),\n      zoomControl: (parseInt(settings.zoomControl) !== 0),\n      mapTypeControl: (parseInt(settings.mapTypeControl) !== 0),\n      scaleControl: (parseInt(settings.scaleControl) !== 0),\n      streetViewControl: (parseInt(settings.streetViewControl) !== 0),\n      fullscreenControl: (parseInt(settings.fullScreenControl) !== 0),\n      scrollwheel: settings.activateScrollWheel,\n      styles: ''\n    };\n\n    if (settings.styles) {\n      mapOptions.styles = eval(settings.styles);\n    }\n\n    switch (settings.mapTypeId) {\n      case 'google.maps.MapTypeId.HYBRID':\n      case 'hybrid':\n        mapOptions.mapTypeId = google.maps.MapTypeId.HYBRID;\n        break;\n      case 'google.maps.MapTypeId.ROADMAP':\n      case 'roadmap':\n        mapOptions.mapTypeId = google.maps.MapTypeId.ROADMAP;\n        break;\n      case 'google.maps.MapTypeId.SATELLITE':\n      case 'satellite':\n        mapOptions.mapTypeId = google.maps.MapTypeId.SATELLITE;\n        break;\n      case 'google.maps.MapTypeId.TERRAIN':\n      case 'terrain':\n        mapOptions.mapTypeId = google.maps.MapTypeId.TERRAIN;\n        break;\n    }\n\n    return mapOptions;\n  }\n\n  /**\n   * Returns CircleOptions which can be assigned to the Circle object of Google\n   *\n   * @param {L.Map} map\n   * @param {object} centerPosition\n   * @param {PoiCollection} poiCollection\n   * @return {object}\n   */\n  getCircleOptions (map, centerPosition, poiCollection) {\n    return {\n      map: map,\n      center: centerPosition,\n      radius: poiCollection.radius,\n      strokeColor: poiCollection.strokeColor,\n      strokeOpacity: poiCollection.strokeOpacity,\n      strokeWeight: poiCollection.strokeWeight,\n      fillColor: poiCollection.fillColor,\n      fillOpacity: poiCollection.fillOpacity\n    };\n  }\n\n  /**\n   * Returns PolygonOptions which can be assigned to the Polygon object of Google\n   *\n   * @param {object} paths\n   * @param {PoiCollection} poiCollection\n   * @return {object}\n   */\n  getPolygonOptions (paths, poiCollection) {\n    return {\n      paths: paths,\n      strokeColor: poiCollection.strokeColor,\n      strokeOpacity: poiCollection.strokeOpacity,\n      strokeWeight: poiCollection.strokeWeight,\n      fillColor: poiCollection.fillColor,\n      fillOpacity: poiCollection.fillOpacity\n    };\n  }\n\n  /**\n   * Return PolylineOptions which can be assigned to the Polyline object of Google\n   *\n   * @param {object} paths\n   * @param {PoiCollection} poiCollection\n   * @return {object}\n   */\n  getPolylineOptions (paths, poiCollection) {\n    return {\n      path: paths,\n      strokeColor: poiCollection.strokeColor,\n      strokeOpacity: poiCollection.strokeOpacity,\n      strokeWeight: poiCollection.strokeWeight,\n    };\n  }\n\n  /**\n   * Create Map\n   *\n   * @param {HTMLElement} element\n   * @param {Environment} environment\n   */\n  createMap (element, environment) {\n    this.map = new google.maps.Map(\n      element,\n      this.getMapOptions(environment.settings)\n    );\n  }\n\n  /**\n   * @param {string | number} value\n   * @return {boolean}\n   */\n  canBeInterpretedAsNumber(value) {\n    return typeof value === 'number' || !isNaN(Number(value));\n  }\n\n  /**\n   * @param {string | number} dimension\n   * @returns {string}\n   */\n  normalizeDimension(dimension) {\n    let normalizedDimension = String(dimension);\n\n    if (this.canBeInterpretedAsNumber(normalizedDimension)) {\n      normalizedDimension += 'px';\n    }\n\n    return normalizedDimension;\n  }\n\n  /**\n   * @param {Settings} settings\n   * @returns {boolean}\n   */\n  shouldFitBounds(settings) {\n    if (settings.forceZoom === true) {\n      return false;\n    }\n\n    if (this.poiCollections === null) {\n      return false;\n    }\n\n    if (this.poiCollections.length > 1) {\n      return true;\n    }\n\n    if (\n      this.poiCollections.length === 1\n      && (\n        this.poiCollections[0].collectionType === \"Area\"\n        || this.poiCollections[0].collectionType === \"Route\"\n      )\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * @param {HTMLElement} element\n   * @param {Settings} settings\n   */\n  setMapDimensions(element, settings) {\n    element.style.height = this.normalizeDimension(settings.mapHeight);\n    element.style.width = this.normalizeDimension(settings.mapWidth);\n  }\n\n  /**\n   * Group Categories\n   *\n   * @param {Environment} environment\n   */\n  groupCategories = environment => {\n    let groupedCategories = {};\n    let categoryUid = \"0\";\n    for (let x = 0; x < this.poiCollections.length; x++) {\n      for (let y = 0; y < this.poiCollections[x].categories.length; y++) {\n        categoryUid = String(this.poiCollections[x].categories[y].uid);\n        if (this.inList(environment.settings.categories, categoryUid) > -1 && !groupedCategories.hasOwnProperty(categoryUid)) {\n          groupedCategories[categoryUid] = this.poiCollections[x].categories[y];\n        }\n      }\n    }\n\n    return groupedCategories;\n  };\n\n  /**\n   * Get categories of all checkboxes with a given status\n   *\n   * @param {HTMLElement} form The HTML form element containing the checkboxes\n   * @param {boolean} isChecked Get checkboxes of this status only\n   */\n  getCategoriesOfCheckboxesWithStatus = (form, isChecked) => {\n    let categories = [];\n    let checkboxes = isChecked ? form.querySelectorAll(\"input:checked\") : form.querySelectorAll(\"input:not(input:checked)\");\n\n    checkboxes.forEach(checkbox => {\n      categories.push(parseInt(checkbox.value));\n    });\n\n    return categories;\n  }\n\n  getMarkersToChangeVisibilityFor = (categoryUid, form, isChecked) => {\n    let markers = [];\n    if (this.allMarkers.length === 0) {\n      return markers;\n    }\n\n    let marker = null;\n    let allCategoriesOfMarker = null;\n    let categoriesOfCheckboxesWithStatus = this.getCategoriesOfCheckboxesWithStatus(form, isChecked);\n    for (let i = 0; i < this.allMarkers.length; i++) {\n      marker = this.allMarkers[i];\n      allCategoriesOfMarker = marker.poiCollection.categories;\n      if (allCategoriesOfMarker.length === 0) {\n        continue;\n      }\n\n      let markerCategoryHasCheckboxWithStatus;\n      for (let j = 0; j < allCategoriesOfMarker.length; j++) {\n        markerCategoryHasCheckboxWithStatus = false;\n        for (let k = 0; k < categoriesOfCheckboxesWithStatus.length; k++) {\n          if (allCategoriesOfMarker[j].uid === categoriesOfCheckboxesWithStatus[k]) {\n            markerCategoryHasCheckboxWithStatus = true;\n          }\n        }\n        if (markerCategoryHasCheckboxWithStatus === isChecked) {\n          break;\n        }\n      }\n\n      if (markerCategoryHasCheckboxWithStatus) {\n        markers.push(marker.marker);\n      }\n    }\n\n    return markers;\n  }\n\n  /**\n   * Show switchable categories\n   *\n   * @param {HTMLElement} element\n   * @param {Environment} environment\n   */\n  showSwitchableCategories = (element, environment) => {\n    let categories = this.groupCategories(environment);\n    let form = document.createElement(\"form\");\n    let span = {};\n\n    form.classList.add(\"txMaps2Form\");\n    form.setAttribute(\"id\", \"txMaps2Form-\" + environment.contentRecord.uid);\n\n    // Add checkbox for category\n    for (let categoryUid in categories) {\n      if (categories.hasOwnProperty(categoryUid)) {\n        form.appendChild(this.getCheckbox(categories[categoryUid]));\n        form.querySelector(\"#checkCategory_\" + categoryUid)?.insertAdjacentHTML(\n          \"afterend\",\n          `<span class=\"map-category\">${categories[categoryUid].title}</span>`\n        );\n      }\n    }\n\n    // Add listener for checkboxes\n    form.querySelectorAll(\"input\").forEach((checkbox) => {\n      checkbox.addEventListener(\"click\", () => {\n        let isChecked = (checkbox).checked;\n        let categoryUid = (checkbox).value;\n        let markers = this.getMarkersToChangeVisibilityFor(categoryUid, form, isChecked);\n\n        markers.forEach((marker) => {\n          marker.setVisible(isChecked);\n        });\n      });\n    });\n\n    element.insertAdjacentElement(\"afterend\", form);\n  }\n\n  /**\n   * Get Checkbox for Category\n   *\n   * @param category\n   */\n  getCheckbox(category) {\n    let div = document.createElement(\"div\");\n    div.classList.add(\"form-group\");\n    div.innerHTML = `\n      <div class=\"checkbox\">\n          <label>\n              <input type=\"checkbox\" class=\"checkCategory\" id=\"checkCategory_${category.uid}\" checked=\"checked\" value=\"${category.uid}\">\n          </label>\n      </div>`;\n\n    return div;\n  }\n\n  /**\n   * Count Object properties\n   *\n   * @param obj\n   */\n  countObjectProperties = obj => {\n    let count = 0;\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /**\n   * Create Point by CollectionType\n   *\n   * @param {HTMLElement} element\n   * @param {Environment} environment\n   */\n  createPointByCollectionType = (element, environment) => {\n    let marker;\n    let categoryUid = 0;\n\n    if (this.poiCollections !== null && this.poiCollections.length) {\n      this.poiCollections.forEach(poiCollection => {\n        if (poiCollection.strokeColor === \"\") {\n          poiCollection.strokeColor = environment.extConf.strokeColor;\n        }\n        if (poiCollection.strokeOpacity === \"\") {\n          poiCollection.strokeOpacity = environment.extConf.strokeOpacity;\n        }\n        if (poiCollection.strokeWeight === \"\") {\n          poiCollection.strokeWeight = environment.extConf.strokeWeight;\n        }\n        if (poiCollection.fillColor === \"\") {\n          poiCollection.fillColor = environment.extConf.fillColor;\n        }\n        if (poiCollection.fillOpacity === \"\") {\n          poiCollection.fillOpacity = environment.extConf.fillOpacity;\n        }\n\n        marker = null;\n        switch (poiCollection.collectionType) {\n          case \"Point\":\n            marker = this.createMarker(poiCollection, element, environment);\n            break;\n          case \"Area\":\n            marker = this.createArea(poiCollection, environment);\n            break;\n          case \"Route\":\n            marker = this.createRoute(poiCollection, environment);\n            break;\n          case \"Radius\":\n            marker = this.createRadius(poiCollection, environment);\n            break;\n        }\n\n        if (marker !== null) {\n          this.allMarkers.push({\n            marker: marker,\n            poiCollection: poiCollection\n          });\n\n          categoryUid = 0;\n          for (let c = 0; c < poiCollection.categories.length; c++) {\n            categoryUid = poiCollection.categories[c].uid;\n            if (!this.categorizedMarkers.hasOwnProperty(categoryUid)) {\n              this.categorizedMarkers[categoryUid] = [];\n            }\n            this.categorizedMarkers[categoryUid].push({\n              marker: marker,\n              relatedCategories: poiCollection.categories\n            });\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Create Marker with InfoWindow\n   *\n   * @param {PoiCollection} poiCollection\n   * @param {HTMLElement} element\n   * @param {Environment} environment\n   */\n  createMarker = (poiCollection, element, environment) => {\n    let categoryUid = \"0\";\n    let marker = new google.maps.Marker({\n      position: new google.maps.LatLng(poiCollection.latitude, poiCollection.longitude),\n      map: this.map\n    });\n    marker.setDraggable(this.editable);\n\n    // assign first found marker icon, if available\n    if (poiCollection.hasOwnProperty(\"markerIcon\") && poiCollection.markerIcon !== \"\") {\n      let icon = {\n        url: poiCollection.markerIcon,\n        scaledSize: new google.maps.Size(poiCollection.markerIconWidth, poiCollection.markerIconHeight),\n        anchor: new google.maps.Point(poiCollection.markerIconAnchorPosX, poiCollection.markerIconAnchorPosY)\n      };\n      marker.setIcon(icon);\n    }\n\n    this.pointMarkers.push(marker);\n    this.bounds.extend(marker.position);\n\n    if (this.editable) {\n      this.addEditListeners(element, marker, poiCollection, environment);\n    } else {\n      this.addInfoWindow(marker, poiCollection, environment);\n    }\n\n    return marker;\n  }\n\n  /**\n   * Create Area\n   *\n   * @param poiCollection\n   * @param environment\n   */\n  createArea = (poiCollection, environment) => {\n    let latLng;\n    let paths = [];\n    for (let i = 0; i < poiCollection.pois.length; i++) {\n      latLng = new google.maps.LatLng(poiCollection.pois[i].latitude, poiCollection.pois[i].longitude);\n      this.bounds.extend(latLng);\n      paths.push(latLng);\n    }\n\n    if (paths.length === 0) {\n      paths.push(this.mapPosition);\n    }\n\n    let area = new google.maps.Polygon(this.getPolygonOptions(paths, poiCollection));\n    area.setMap(this.map);\n    this.addInfoWindow(area, poiCollection, environment);\n\n    return area;\n  }\n\n  /**\n   * Create Route\n   *\n   * @param poiCollection\n   * @param environment\n   */\n  createRoute = (poiCollection, environment) => {\n    let latLng;\n    let paths = [];\n    for (let i = 0; i < poiCollection.pois.length; i++) {\n      latLng = new google.maps.LatLng(poiCollection.pois[i].latitude, poiCollection.pois[i].longitude);\n      this.bounds.extend(latLng);\n      paths.push(latLng);\n    }\n\n    if (paths.length === 0) {\n      paths.push(this.mapPosition);\n    }\n\n    let route = new google.maps.Polyline(this.getPolylineOptions(paths, poiCollection));\n    route.setMap(this.map);\n    this.addInfoWindow(route, poiCollection, environment);\n\n    return route;\n  }\n\n  /**\n   * Create Radius\n   *\n   * @param poiCollection\n   * @param environment\n   */\n  createRadius = (poiCollection, environment) => {\n    let circle = new google.maps.Circle(\n      this.getCircleOptions(\n        this.map,\n        new google.maps.LatLng(poiCollection.latitude, poiCollection.longitude),\n        poiCollection\n      )\n    );\n\n    this.bounds.union(circle.getBounds());\n    this.addInfoWindow(circle, poiCollection, environment);\n\n    return circle;\n  }\n\n  /**\n   * Add Info Window to element\n   *\n   * @param element\n   * @param poiCollection\n   * @param environment\n   */\n  addInfoWindow = (element, poiCollection, environment) => {\n    // we need these both vars to be set global. So that we can access them in Listener\n    let infoWindow = this.infoWindow;\n    let map = this.map;\n    google.maps.event.addListener(element, \"click\", event => {\n      fetch(environment.ajaxUrl, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          poiCollection: poiCollection.uid\n        })\n      })\n        .then(response => response.json())\n        .then(data => {\n          infoWindow.close();\n          infoWindow.setContent(data.content);\n\n          // Do not set pointer of InfoWindow to the same pointer of the POI icon.\n          // In case of Point the pointer of InfoWindow should be at mouse position.\n          if (poiCollection.collectionType === \"Point\") {\n            infoWindow.setPosition(null);\n            infoWindow.open(map, element);\n          } else {\n            infoWindow.setPosition(new google.maps.LatLng(poiCollection.latitude, poiCollection.longitude));\n            infoWindow.open(map);\n          }\n        })\n        .catch(error => console.error('Error:', error));\n    });\n  }\n\n  /**\n   * Check for item in list\n   * Check if an item exists in a comma-separated list of items.\n   *\n   * @param list\n   * @param item\n   */\n  inList = (list, item) => {\n    let catSearch = ',' + list + ',';\n    item = ',' + item + ',';\n    return catSearch.search(item);\n  };\n\n  /**\n   * Create Marker with InfoWindow\n   *\n   * @param latitude\n   * @param longitude\n   */\n  createMarkerByLatLng = (latitude, longitude) => {\n    let marker = new google.maps.Marker({\n      position: new google.maps.LatLng(latitude, longitude),\n      map: this.map\n    });\n    this.bounds.extend(marker.position);\n  };\n\n  /**\n   * Add Edit Listeners\n   * This will only work for Markers (Point)\n   *\n   * @param mapContainer\n   * @param marker\n   * @param poiCollection\n   * @param environment\n   */\n  addEditListeners = (mapContainer, marker, poiCollection, environment) => {\n    // update fields and marker while dragging\n    google.maps.event.addListener(marker, 'dragend', () => {\n      let lat = marker.getPosition().lat().toFixed(6);\n      let lng = marker.getPosition().lng().toFixed(6);\n      mapContainer.prevAll(\"input.latitude-\" + environment.contentRecord.uid).val(lat);\n      mapContainer.prevAll(\"input.longitude-\" + environment.contentRecord.uid).val(lng);\n    });\n\n    // update fields and marker when clicking on the map\n    google.maps.event.addListener(this.map, 'click', event => {\n      marker.setPosition(event.latLng);\n      mapContainer.prevAll(\"input.latitude-\" + environment.contentRecord.uid).val(event.latLng.lat().toFixed(6));\n      mapContainer.prevAll(\"input.longitude-\" + environment.contentRecord.uid).val(event.latLng.lng().toFixed(6));\n    });\n  };\n}\n\nlet maps2GoogleMaps = [];\n\n/**\n * This function will be called by the &callback argument of the Google Maps API library\n */\nfunction initMap () {\n  document.querySelectorAll(\".maps2\").forEach(element => {\n    const environment = typeof element.dataset.environment !== 'undefined' ? element.dataset.environment : '{}';\n    const override = typeof element.dataset.override !== 'undefined' ? element.dataset.override : '{}';\n\n    // Pass in the objects to merge as arguments.\n    // For a deep extend, set the first argument to `true`.\n    const extend = (...arguments) => {\n      let extended = {};\n      let deep = false;\n      let i = 0;\n      let length = arguments.length;\n\n      // Check for deep merge\n      if (Object.prototype.toString.call(arguments[0]) === '[object Boolean]') {\n        deep = arguments[0];\n        i++;\n      }\n\n      // Merge the object into the extended object\n      const merge = function (obj) {\n        for ( var prop in obj ) {\n          if ( Object.prototype.hasOwnProperty.call( obj, prop ) ) {\n            // If deep merge and property is an object, merge properties\n            if ( deep && Object.prototype.toString.call(obj[prop]) === '[object Object]' ) {\n              extended[prop] = extend( true, extended[prop], obj[prop] );\n            } else {\n              extended[prop] = obj[prop];\n            }\n          }\n        }\n      };\n\n      // Loop through each object and conduct a merge\n      for ( ; i < length; i++ ) {\n        var obj = arguments[i];\n        merge(obj);\n      }\n\n      return extended;\n    };\n\n    maps2GoogleMaps.push(new GoogleMaps2(\n      element,\n      extend(JSON.parse(environment), JSON.parse(override))\n    ));\n  });\n\n  // Initialize radius search\n  let address = document.querySelector('#maps2Address');\n  let radius = document.querySelector('#maps2Radius');\n  if (address !== null && radius !== null) {\n    let autocomplete = new google.maps.places.Autocomplete(address, {\n      fields: [\n        \"place_id\"\n      ]\n    });\n\n    address.addEventListener(\"keydown\", event => {\n      if (event.keyCode === 13) return false;\n    });\n  }\n}\n"]}